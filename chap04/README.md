### 4.1 
`5+10*20/2=105`

### 4.2
- `*(vec.begin())`
- `*((vec.begin()))+1`

### 4.3
可以接受。C++的设计思想是尽可能地“相信”程序员，将效率最大化。然而这种思想却有着潜在的危害，就是无法控制程序员自身引发的错误。因此 Java 的诞生也是必然，Java的思想就是尽可能地“不相信”程序员。

### 4.4 [代码](prog4-4.cc)
`((12/3)*4) + (5*15) + ((24%4)/2)=91`

### 4.5
- -86
- -18
- 0
- -2

### 4.6
```c++
if (x % 2 == 0) /*偶数*/
```

### 4.7
溢出指运算结果不能使用已有的bit位数来保存
```
short svalue = 32767; ++svalue; // -32768
unsigned uivalue = 0; --uivalue;  // 4294967295
unsigned short usvalue = 65535; ++usvalue;  // 0
```

### 4.8
逻辑与和逻辑或，都是在左侧无法满足的情况下，计算右侧，其中，逻辑与左侧为真，接着计算右侧，逻辑或左侧为假，接着计算右侧，这种策略称为短路求值
相等性运算符则没有定义这种顺序

### 4.9
首先判断`cp`是否为空指针，不为空指针的话，接着判断`*cp`是否是空字符串

### 4.10
```c++
int input = 0;
while (cin >> input && input != 42) {}
```

### 4.11
```c++
if (a > b && b > c && c > d) {}
```

### 4.12
根据优先级，先算`j<k`得到`bool`值，然后再拿这个`bool`值跟整数`i`来比较，`bool`值便会被整形提升成0或者1，然后比较，最后得到`i`是否为1或0的`bool`值。

### 4.13
- i=3, d=3.0
- i=3, d=3.5

### 4.14
- 出错，右值不可被赋值
- 始终为真

### 4.15
pi是`int*`类型，不可赋值给ival，应该改为`dval=ival=*pi=0;`

### 4.16
- if ((p =getPtr()) != 0)
- if (i == 1024)

### 4.17
他们两都只能操纵左值对象，其中前置递增运算符将对象递增之后返回该对象，后置递增运算符将对象递增之后，返回递增之前该对象的一个副本

### 4.18
使用前置运算符，那么代表在解引用之前，指针值已经加1，将会非法访问到不存在的元素，同时，第一个元素将不会被输出

### 4.19
- 判断指针值和指针所指对象是否为0，不是0的话则移动到下一个位置
- 判断ival是否为0，以及(ival+1)是否为0
- 非法，`<=`运算符并未定义左边优先还是右边优先，左右两边用了相同的对象，结果未定义，应该改为`vec[ival] <= vec[ival+1]`

### 4.20
- `*iter++` 合法，获得当前的字符串，然后将迭代器往后移一个位置
- `(*iter)++` 不合法，先解引用得到一个`string`对象，但该对象不支持`++`的操作符
- `*iter.empty()` 不合法，先执行点运算符，但是`iter`没有成员函数`empty()`
- `iter->empty()` 合法，检查当前字符串是否为空，相当于`(*iter).empty()`
- `++*iter` 不合法，先解引用，`string`对象没有`++`操作
- `iter++->empty()` 合法，判断当前字符串是否为空，然后将迭代器往后移一个位置

### 4.21 [代码](prog4-21.cc)

### 4.22 [代码](prog4-22.cc)
使用if的版本更加容易理解，因为当嵌套层增多之后，条件运算符可读性急剧降低

### 4.23
如果不加括号的话，s会首先与最后一个字符相加，然后与's'做比较，字符串和字符比较将会出错，应该修改如下
```c++
string p1 = s + ((s[s.size()-1] == 's') ? "" : "s";)
```

### 4.24
如果条件运算符满足右结合律，则
```c++
finalgrade = (grade > 90) ? "high pass" : ((grade < 60) ? "fail" : "pass");
```
如果条件运算符满足左结合律，则
```c++
finalgrade = ((grade > 90) ? "high pass" : (grade < 60)) ? "fail" : "pass";
```
在左结合律下，grade为90的时候，表达式结果为"high pass"，非空，那么在后面的条件运算符上，一定为真，则finalgrade的结果是fail，明显是不符合程序的意图的。

### 4.25 [代码](prog2-25.cc)
首先`q`提升成为整型，然后取反得到`1111 1111 1111 1111 1111 1111 1000 1110`，然后往右移6位，最终结果为`1111 1111 1111 1111 1110 0011 1000 0000`，最终结果为`-7296`

### 4.26
unsigned int只保证占16位，而运算结果超过了16位，是未定义的行为

### 4.27 
- 3 & 7 = 3
- 3 | 7 = 7
- 3 && 7 = true
- 3 || 7 = true

### 4.28 [代码](prog4-28.cc)

### 4.29 [代码](prog4-29.cc)
第一个是10，第二个结果未定义，第一个是数组，sizeof用在数组时候，不会进行隐式转换成指针，sizeof直接求指针，我的机器上的值是8，而一个整型占4，那么这个结果是2

### 4.30
- sizeof(x) + y
- sizeof(p->mem[i])
- sizeof(a) < b
- sizeof(f())

### 4.31
前置版本直接操作原始对象，后置版本在操作原始对象之前，会创建一份原始对象的副本，将导致额外的开销，这里不用改变

### 4.32
遍历数组ia，ix和ptr都起到一个控制循环计数和终止的条件

### 4.33
条件表达式比逗号表达式的优先级高，前置递增和递减的比逗号表达式高，因此，这里的是如果，someValue为真的话，则将x和y都增加1之后，返回y的值，否则将x减一之后，返回x的值，用括号如下
```c++
(someValue ? ++x, ++y : --x), --y
```

### 4.34
- 浮点型转化为布尔型
- ival转化为浮点型，然后得到的浮点运算结果再转化为双精度浮点型
- 首先cval被提升为int型，然后进行乘运算，将乘运算的结果转化乘double型，与dval相加

### 4.35
- 发生了，'a'整型提升，然后结果再转化为char类型
- 发生了，ival转化为double类型，ui转化为double类型，最后运算结果转化为float类型
- 发生了，ui转化为float类型，乘积结果转化为double类型
- 发生了，ival首先转为float类型，相加结果转化为double类型，最后结果转化为char类型

### 4.36
`i *= static_cast<int>(d);`

### 4.37
- `pv=static_cast<void*>(ps)`
- `i=static_cast<int>(*pc)`
- `pv = static_cast<void*>(&d);`
- `pc = static_cast<char*>(pv);`

### 4.38
将j/i的结果显示转化成为double类型，然后赋值给slope
