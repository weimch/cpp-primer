### 3.2 [代码](prog3-2.cc)

### 3.3
string类的输入运算符遇到空白字符时候，跳过空白字符直到第一个可读字符，然后读取直到遇到下一个空白字符或者结束符，然后读取出来一个字符串，而getline以换行符来触发读取，将会以行来读取数据，并在赋值string对象时候把`换行符`去掉。

### 3.4 [代码](prog3-4.cc)

### 3.5 [代码](prog3-5.cc)

### 3.6 [代码](prog3-6.cc)

### 3.7 [代码](prog3-7.cc)
将不会有改变

### 3.9
不合法，因为s初始化为空字符串，`s[0]`行为未定义

### 3.10 [代码](prog3-10.cc)

### 3.11
c的类型是`cosnt char &`，因此，如果for内不改变c的值，就是合法的，改变了就是非法的

### 3.12
- (a) `vector<vector<int>> ivec;` 正确，创建一个包含vector<int>的vector
- (b) `vector<string> svec = ivec;` 错误，ivec和svec类型不一样，不可直接赋值
- (c) `vectro<string> svec(10, "null");` 正确，产生10个元素，每个元素的值是"null"

### 3.13
- (a) 0个
- (b) 10个, 0
- (c) 10个，42
- (d) 1个，10
- (e) 2个，10和42
- (f) 10个，""
- (g) 10个，每个元素是"hi"

### 3.14 [代码](prog3-14.cc)

### 3.15 [代码](prog3-15.cc)

### 3.16 [代码](prog3-16.cc)

### 3.17 [代码](prog3-17.cc)

### 3.18
不合法，因为ivec内还不存在元素，更改如下
```C++
vector<int> ivec;
ivec.push_back(42);
```

### 3.19
```C++
vector<int> ivec(10, 42); // 这种要好，简单明了
vector<int> ivec{42, 42, 42, 42, 42, 42, 42, 42, 42, 42};
vector<int> ivec;
for (decltype(ivec.size()) i = 0; i < 10; ++i) {
  ivec.push_back(42);
}
```

### 3.20 [代码](prog3-20.cc)

### 3.21 [代码](prog3-21.cc)

### 3.22 [代码](prog3-22.cc)

### 3.23 [代码](prog3-23.cc)

### 3.24 [代码](prog3-24.cc)

### 3.25 [代码](prog3-25.cc)

### 3.26
因为同个容器中的迭代器之间加法是未定义的

### 3.27
- (a) 非法，数组的长度需要是常量表达式
- (b) 合法
- (c) 非法，txt_size()只有计算之后才能知道，不是常量表达式
- (d) 非法，数组长度不够，长度应该为12

### 3.28
```C++
string sa[10]; // 10个""字符
int ia[10]; // 10个0
int main() {
  string sa2[10]; // 10个空字符
  int ia2[10]; // 10个数字，数字具体值未定义
}
```

### 3.29
相比于vector来说，数组长度是固定的，不可随意增加其长度，不允许拷贝和赋值

### 3.30
```C++
constexpr size_t array_size = 10;
int ia[array_size];
for (size_t ix = 1; ix <= array_size; ++ix) // 数组长度是10，下表索引从0~9
  ia[ix] = ix;
```
### 3.31 [代码](prog3-32.cc)

### 3.32 [代码](prog3-32.cc)

### 3.33
不初始化scores，那么数组内的值将是未定义的，后续使用会出错

### 3.34
p1移动到p2的位置，任何情况下都是合法的

### 3.35 [代码](prog3-35.cc)

### 3.36 [代码](prog3-36.cc)

### 3.37
定义一个const char的数组ca, 使用cp获取数组指针，判断当前`*cp`的值是否为0，不为0的话输出`*cp`然后指针加1，输出将是未定义的，因为ca末尾结束的字符不是0，也就是说，循环可能会持续直到遇到第一个为0的位置

### 3.38
指针相减，可以得到两个指针的位置，但指针相加并没有什么逻辑上的意义

### 3.39 [代码](prog3-39.cc)

### 3.40 [代码](prog3-40.cc)

### 3.41 [代码](prog3-41.cc)

### 3.42 [代码](prog3-42.cc)

### 3.43 [代码](prog3-43.cc)

### 3.44 [代码](prog3-44.cc)

### 3.45 [代码](prog3-45.cc)
